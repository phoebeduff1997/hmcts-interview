A list of trade offs made while building this application

## Database
    For ease of local set up I have opted to use a local in memory database. This would usually be better served for
    integration tests, but to simulate a "live" environment the database is prepopulated with data on load

## Overdue scheduler
    I have set up a default async task executor to handle the Server Sent Event (SSE) implemented to return the updated
    overdue tasks. This has been set up with some small numbers as this is a demo only. If this was in production I
    would change out the spring MVC dependency for webflux, as MVC is a blocking thread and webflux isnt. I didnt want
    to engage in premature optimisation in a demo app

## Logging
    The spec document didnt ask for logging so I have only explicity logged the backend. If this was local/small
    scale production code (e.g. a desktop app or a small internal tool) I would configure the frontend error handler
    to send the logs to the backend and log for agregated error logging. If this was a live instance with many users,
    I would consider other tools like Sentry/Datadog/Elastic depending on requirements

## Pagination
    If the application was expected to handle a large number of tasks, the get requests would be paged, and the
    frontend would implement pagination to allow the user to go through all the tasks, while reducing the size of the
    requests and the load time on the frontend 
